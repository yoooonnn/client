{"ast":null,"code":"'use strict';\n\nvar hash = require('hash.js');\nvar curves = require('../curves');\nvar utils = require('../utils');\nvar assert = utils.assert;\nvar parseBytes = utils.parseBytes;\nvar KeyPair = require('./key');\nvar Signature = require('./signature');\nfunction EDDSA(curve) {\n  assert(curve === 'ed25519', 'only tested with ed25519 so far');\n  if (!(this instanceof EDDSA)) return new EDDSA(curve);\n  curve = curves[curve].curve;\n  this.curve = curve;\n  this.g = curve.g;\n  this.g.precompute(curve.n.bitLength() + 1);\n  this.pointClass = curve.point().constructor;\n  this.encodingLength = Math.ceil(curve.n.bitLength() / 8);\n  this.hash = hash.sha512;\n}\nmodule.exports = EDDSA;\n\n/**\n* @param {Array|String} message - message bytes\n* @param {Array|String|KeyPair} secret - secret bytes or a keypair\n* @returns {Signature} - signature\n*/\nEDDSA.prototype.sign = function sign(message, secret) {\n  message = parseBytes(message);\n  var key = this.keyFromSecret(secret);\n  var r = this.hashInt(key.messagePrefix(), message);\n  var R = this.g.mul(r);\n  var Rencoded = this.encodePoint(R);\n  var s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv());\n  var S = r.add(s_).umod(this.curve.n);\n  return this.makeSignature({\n    R: R,\n    S: S,\n    Rencoded: Rencoded\n  });\n};\n\n/**\n* @param {Array} message - message bytes\n* @param {Array|String|Signature} sig - sig bytes\n* @param {Array|String|Point|KeyPair} pub - public key\n* @returns {Boolean} - true if public key matches sig of message\n*/\nEDDSA.prototype.verify = function verify(message, sig, pub) {\n  message = parseBytes(message);\n  sig = this.makeSignature(sig);\n  if (sig.S().gte(sig.eddsa.curve.n) || sig.S().isNeg()) {\n    return false;\n  }\n  var key = this.keyFromPublic(pub);\n  var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);\n  var SG = this.g.mul(sig.S());\n  var RplusAh = sig.R().add(key.pub().mul(h));\n  return RplusAh.eq(SG);\n};\nEDDSA.prototype.hashInt = function hashInt() {\n  var hash = this.hash();\n  for (var i = 0; i < arguments.length; i++) hash.update(arguments[i]);\n  return utils.intFromLE(hash.digest()).umod(this.curve.n);\n};\nEDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {\n  return KeyPair.fromPublic(this, pub);\n};\nEDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {\n  return KeyPair.fromSecret(this, secret);\n};\nEDDSA.prototype.makeSignature = function makeSignature(sig) {\n  if (sig instanceof Signature) return sig;\n  return new Signature(this, sig);\n};\n\n/**\n* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2\n*\n* EDDSA defines methods for encoding and decoding points and integers. These are\n* helper convenience methods, that pass along to utility functions implied\n* parameters.\n*\n*/\nEDDSA.prototype.encodePoint = function encodePoint(point) {\n  var enc = point.getY().toArray('le', this.encodingLength);\n  enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;\n  return enc;\n};\nEDDSA.prototype.decodePoint = function decodePoint(bytes) {\n  bytes = utils.parseBytes(bytes);\n  var lastIx = bytes.length - 1;\n  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);\n  var xIsOdd = (bytes[lastIx] & 0x80) !== 0;\n  var y = utils.intFromLE(normed);\n  return this.curve.pointFromY(y, xIsOdd);\n};\nEDDSA.prototype.encodeInt = function encodeInt(num) {\n  return num.toArray('le', this.encodingLength);\n};\nEDDSA.prototype.decodeInt = function decodeInt(bytes) {\n  return utils.intFromLE(bytes);\n};\nEDDSA.prototype.isPoint = function isPoint(val) {\n  return val instanceof this.pointClass;\n};","map":{"version":3,"names":["hash","require","curves","utils","assert","parseBytes","KeyPair","Signature","EDDSA","curve","g","precompute","n","bitLength","pointClass","point","constructor","encodingLength","Math","ceil","sha512","module","exports","prototype","sign","message","secret","key","keyFromSecret","r","hashInt","messagePrefix","R","mul","Rencoded","encodePoint","s_","pubBytes","priv","S","add","umod","makeSignature","verify","sig","pub","gte","eddsa","isNeg","keyFromPublic","h","SG","RplusAh","eq","i","arguments","length","update","intFromLE","digest","fromPublic","fromSecret","enc","getY","toArray","getX","isOdd","decodePoint","bytes","lastIx","normed","slice","concat","xIsOdd","y","pointFromY","encodeInt","num","decodeInt","isPoint","val"],"sources":["/Users/yoon/Documents/React/authentication/node_modules/elliptic/lib/elliptic/eddsa/index.js"],"sourcesContent":["'use strict';\n\nvar hash = require('hash.js');\nvar curves = require('../curves');\nvar utils = require('../utils');\nvar assert = utils.assert;\nvar parseBytes = utils.parseBytes;\nvar KeyPair = require('./key');\nvar Signature = require('./signature');\n\nfunction EDDSA(curve) {\n  assert(curve === 'ed25519', 'only tested with ed25519 so far');\n\n  if (!(this instanceof EDDSA))\n    return new EDDSA(curve);\n\n  curve = curves[curve].curve;\n  this.curve = curve;\n  this.g = curve.g;\n  this.g.precompute(curve.n.bitLength() + 1);\n\n  this.pointClass = curve.point().constructor;\n  this.encodingLength = Math.ceil(curve.n.bitLength() / 8);\n  this.hash = hash.sha512;\n}\n\nmodule.exports = EDDSA;\n\n/**\n* @param {Array|String} message - message bytes\n* @param {Array|String|KeyPair} secret - secret bytes or a keypair\n* @returns {Signature} - signature\n*/\nEDDSA.prototype.sign = function sign(message, secret) {\n  message = parseBytes(message);\n  var key = this.keyFromSecret(secret);\n  var r = this.hashInt(key.messagePrefix(), message);\n  var R = this.g.mul(r);\n  var Rencoded = this.encodePoint(R);\n  var s_ = this.hashInt(Rencoded, key.pubBytes(), message)\n    .mul(key.priv());\n  var S = r.add(s_).umod(this.curve.n);\n  return this.makeSignature({ R: R, S: S, Rencoded: Rencoded });\n};\n\n/**\n* @param {Array} message - message bytes\n* @param {Array|String|Signature} sig - sig bytes\n* @param {Array|String|Point|KeyPair} pub - public key\n* @returns {Boolean} - true if public key matches sig of message\n*/\nEDDSA.prototype.verify = function verify(message, sig, pub) {\n  message = parseBytes(message);\n  sig = this.makeSignature(sig);\n  if (sig.S().gte(sig.eddsa.curve.n) || sig.S().isNeg()) {\n    return false;\n  }\n  var key = this.keyFromPublic(pub);\n  var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);\n  var SG = this.g.mul(sig.S());\n  var RplusAh = sig.R().add(key.pub().mul(h));\n  return RplusAh.eq(SG);\n};\n\nEDDSA.prototype.hashInt = function hashInt() {\n  var hash = this.hash();\n  for (var i = 0; i < arguments.length; i++)\n    hash.update(arguments[i]);\n  return utils.intFromLE(hash.digest()).umod(this.curve.n);\n};\n\nEDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {\n  return KeyPair.fromPublic(this, pub);\n};\n\nEDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {\n  return KeyPair.fromSecret(this, secret);\n};\n\nEDDSA.prototype.makeSignature = function makeSignature(sig) {\n  if (sig instanceof Signature)\n    return sig;\n  return new Signature(this, sig);\n};\n\n/**\n* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2\n*\n* EDDSA defines methods for encoding and decoding points and integers. These are\n* helper convenience methods, that pass along to utility functions implied\n* parameters.\n*\n*/\nEDDSA.prototype.encodePoint = function encodePoint(point) {\n  var enc = point.getY().toArray('le', this.encodingLength);\n  enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;\n  return enc;\n};\n\nEDDSA.prototype.decodePoint = function decodePoint(bytes) {\n  bytes = utils.parseBytes(bytes);\n\n  var lastIx = bytes.length - 1;\n  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);\n  var xIsOdd = (bytes[lastIx] & 0x80) !== 0;\n\n  var y = utils.intFromLE(normed);\n  return this.curve.pointFromY(y, xIsOdd);\n};\n\nEDDSA.prototype.encodeInt = function encodeInt(num) {\n  return num.toArray('le', this.encodingLength);\n};\n\nEDDSA.prototype.decodeInt = function decodeInt(bytes) {\n  return utils.intFromLE(bytes);\n};\n\nEDDSA.prototype.isPoint = function isPoint(val) {\n  return val instanceof this.pointClass;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}